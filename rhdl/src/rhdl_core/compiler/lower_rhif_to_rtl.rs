use std::collections::BTreeMap;

use fnv::FnvHashMap;
use log::debug;

use crate::rhdl_bits::alias::b8;

use crate::rhdl_core::ast::ast_impl::{FunctionId, WrapOp};
use crate::rhdl_core::error::rhdl_error;
use crate::rhdl_core::rhif::spec::{AluBinary, Slot};
use crate::rhdl_core::rtl::object::{RegisterKind, SourceOpCode};
use crate::rhdl_core::rtl::remap::remap_operands;
use crate::rhdl_core::rtl::spec::{CastKind, Concat, LiteralId, Operand, RegisterId};
use crate::rhdl_core::rtl::symbols::SymbolMap;
use crate::rhdl_core::types::bit_string::BitString;
use crate::rhdl_core::types::path::{bit_range, sub_kind, Path, PathElement, PathError};
use crate::rhdl_core::Digital;
use crate::rhdl_core::TypedBits;
use crate::rhdl_core::{rhif, RHDLError};
use crate::rhdl_core::{rtl, Kind};

use crate::rhdl_core::rhif::spec as hf;
use crate::rhdl_core::rtl::spec as tl;

use crate::rhdl_core::compiler::mir::error::{RHDLCompileError, ICE};

type Result<T> = std::result::Result<T, RHDLError>;

struct RTLCompiler<'a> {
    symbols: SymbolMap,
    object: &'a rhif::object::Object,
    literals: BTreeMap<LiteralId, BitString>,
    registers: BTreeMap<RegisterId, RegisterKind>,
    operand_map: BTreeMap<Operand, (FunctionId, Slot)>,
    reverse_operand_map: BTreeMap<(FunctionId, Slot), Operand>,
    ops: Vec<rtl::object::LocatedOpCode>,
    literal_count: usize,
    register_count: usize,
    rhifs: BTreeMap<FunctionId, rhif::Object>,
}

#[derive(Debug, Clone)]
struct DynamicPathInstance {
    concrete_path: Path,
    dynamic_slot_values: FnvHashMap<Slot, usize>,
}

/// This function is similar to [path_star], but it is more
/// special purpose. In [path_star], we calculate the set of
/// all possible paths generated by a template path. So, for example,
/// if the path is a.foo[n].bar[m].baz, we will generate a list
/// of paths of the kind
///      a.foo[0].bar[0].baz
///      a.foo[0].bar[1].baz
///      a.foo[1].bar[0].baz
///          etc.
/// The [path_star] function does not keep track of the assignments used
/// in the process (i.e., what is the assignment for `n` and `m` in each
/// of the above paths).  We need this info for converting dynamic indexing
/// into a lookup table.  So we need the function to return something like
///      (a.foo[0].bar[0].baz, {n -> 0, m -> 0})
///      (a.foo[0].bar[1].baz, {n -> 0, m -> 1})
///      (a.foo[1].bar[0].baz, {n -> 1, m -> 0})
///      (a.foo[1].bar[1].baz, {n -> 1, m -> 1})
fn path_star_with_index_tracking(
    object: &rhif::Object,
    kind: Kind,
    path: &Path,
) -> Result<Vec<DynamicPathInstance>> {
    debug!("path star with index tracking called with kind {kind:?} and path {path:?}");
    if !path.any_dynamic() {
        return Ok(vec![DynamicPathInstance {
            concrete_path: path.clone(),
            dynamic_slot_values: FnvHashMap::default(),
        }]);
    }
    if let Some(element) = path.elements.first() {
        match element {
            PathElement::DynamicIndex(slot) => {
                let Kind::Array(array) = kind else {
                    return Err(rhdl_error(PathError::DynamicIndexOnNonArray {
                        element: element.clone(),
                        kind,
                    }));
                };
                let slot_bits = object.kind(*slot).bits();
                let upper_limit = array.size.min(1 << slot_bits);
                let mut paths = Vec::new();
                for i in 0..upper_limit {
                    let mut path = path.clone();
                    path.elements[0] = PathElement::Index(i);
                    let mut child_paths = path_star_with_index_tracking(object, kind, &path)?;
                    child_paths.iter_mut().for_each(|child| {
                        child.dynamic_slot_values.insert(*slot, i);
                    });
                    paths.extend(child_paths);
                }
                return Ok(paths);
            }
            p => {
                // We have a non-dynamic path element, like a.foo
                // We want to apply it to get the subtype
                let prefix_path = Path {
                    elements: vec![p.clone()],
                };
                // The resulting kind we compute with [sub_kind]
                let prefix_kind = sub_kind(kind, &prefix_path)?;
                // Get a residual path
                let suffix_path = path.strip_prefix(&prefix_path)?;
                // Recurse
                let mut suffix_star =
                    path_star_with_index_tracking(object, prefix_kind, &suffix_path)?;
                suffix_star.iter_mut().for_each(|item| {
                    item.concrete_path = prefix_path.clone().join(&item.concrete_path)
                });
                return Ok(suffix_star);
            }
        }
    }
    Ok(vec![DynamicPathInstance {
        concrete_path: path.clone(),
        dynamic_slot_values: FnvHashMap::default(),
    }])
}

struct DynamicIndexDetails {
    discriminant: Operand,
    table: Box<[(tl::CaseArgument, Path)]>,
}

impl<'a> RTLCompiler<'a> {
    fn new(object: &'a rhif::object::Object) -> Self {
        let mut symbols = SymbolMap::default();
        symbols.source_set = object.symbols.source_set.clone();
        Self {
            object,
            symbols,
            literals: Default::default(),
            registers: Default::default(),
            operand_map: Default::default(),
            reverse_operand_map: Default::default(),
            ops: Default::default(),
            literal_count: 0,
            register_count: 0,
            rhifs: BTreeMap::from([(object.fn_id, object.clone())]),
        }
    }
    fn associate(&mut self, operand: Operand, loc: SourceOpCode) {
        self.symbols.operand_map.insert(operand, loc.into());
    }
    fn allocate_literal(&mut self, bits: &TypedBits, loc: SourceOpCode) -> Operand {
        let bits: BitString = bits.into();
        self.allocate_literal_from_bit_string(&bits, loc)
    }
    fn allocate_literal_from_bit_string(&mut self, bits: &BitString, loc: SourceOpCode) -> Operand {
        if let Some((reuse_id, _)) = self.literals.iter().find(|(id, bs)| {
            bits.eq(bs) && self.symbols.operand_map[&Operand::Literal(**id)] == loc.rhif
        }) {
            return Operand::Literal(*reuse_id);
        }
        let literal_id = LiteralId::new(self.literal_count);
        self.literal_count += 1;
        self.literals.insert(literal_id, bits.clone());
        let literal = Operand::Literal(literal_id);
        self.associate(literal, loc);
        literal
    }
    fn allocate_signed(&mut self, length: usize, loc: SourceOpCode) -> Operand {
        let register_id = RegisterId::new(self.register_count);
        self.register_count += 1;
        self.registers
            .insert(register_id, RegisterKind::Signed(length));
        let register = Operand::Register(register_id);
        self.associate(register, loc);
        register
    }
    fn allocate_unsigned(&mut self, length: usize, loc: SourceOpCode) -> Operand {
        let register_id = RegisterId::new(self.register_count);
        self.register_count += 1;
        self.registers
            .insert(register_id, RegisterKind::Unsigned(length));
        let register = Operand::Register(register_id);
        self.associate(register, loc);
        register
    }
    fn allocate_register(&mut self, kind: &Kind, loc: SourceOpCode) -> Operand {
        let len = kind.bits();
        if kind.is_signed() {
            self.allocate_signed(len, loc)
        } else {
            self.allocate_unsigned(len, loc)
        }
    }
    fn allocate_register_with_register_kind(
        &mut self,
        kind: &RegisterKind,
        loc: SourceOpCode,
    ) -> Operand {
        let register_id = RegisterId::new(self.register_count);
        self.register_count += 1;
        self.registers.insert(register_id, *kind);
        let register = Operand::Register(register_id);
        self.associate(register, loc);
        register
    }
    fn operand_bit_width(&self, operand: Operand) -> usize {
        match operand {
            Operand::Literal(literal_id) => self.literals[&literal_id].len(),
            Operand::Register(register_id) => self.registers[&register_id].len(),
        }
    }
    fn operand_is_signed(&self, operand: Operand) -> bool {
        match operand {
            Operand::Literal(literal_id) => self.literals[&literal_id].is_signed(),
            Operand::Register(register_id) => self.registers[&register_id].is_signed(),
        }
    }
    fn raise_ice(&self, cause: ICE, loc: SourceOpCode) -> RHDLError {
        rhdl_error(RHDLCompileError {
            cause,
            src: self.object.symbols.source(),
            err_span: self.object.symbols.span(loc.into()).into(),
        })
    }
    fn lop(&mut self, opcode: tl::OpCode, loc: SourceOpCode) {
        self.ops.push((opcode, loc).into())
    }
    fn build_dynamic_index(
        &mut self,
        arg_kind: Kind,
        path: &Path,
        loc: SourceOpCode,
    ) -> Result<DynamicIndexDetails> {
        let dynamic_slots: Vec<Slot> = path.dynamic_slots().copied().collect();
        // Each of the selectors should be a register.  Any literals should have
        // been removed.
        if !dynamic_slots
            .iter()
            .all(|&slot| matches!(slot, Slot::Register(_)))
        {
            return Err(self.raise_ice(ICE::DynamicIndexHasLiteral { path: path.clone() }, loc));
        }
        let dynamic_slot_bit_widths = dynamic_slots
            .iter()
            .map(|slot| self.object.kind(*slot).bits())
            .collect::<Vec<usize>>();
        // Calculate the total size of the selector in bits
        let selector_size = dynamic_slot_bit_widths.iter().sum::<usize>();
        // Allocate a register of this size.  It will hold the concatenation of the dynamic slots
        let discriminant = self.allocate_unsigned(selector_size, loc);
        let dynamic_slots_as_operands = dynamic_slots
            .iter()
            .map(|slot| self.operand(*slot, loc))
            .collect::<Result<Vec<_>>>()?;
        self.lop(
            tl::OpCode::Concat(tl::Concat {
                lhs: discriminant,
                args: dynamic_slots_as_operands,
            }),
            loc,
        );
        let path_list = path_star_with_index_tracking(self.object, arg_kind, path)?;
        let mut test_values = vec![];
        for case in &path_list {
            // Map the dynamic slots to their equivalent raw usize values.
            let dyn_slots = dynamic_slots
                .iter()
                .map(|slot| case.dynamic_slot_values[slot])
                .collect::<Vec<_>>();
            let dyn_slot_bit_strings = dyn_slots
                .iter()
                .zip(&dynamic_slot_bit_widths)
                .map(|(&value, &width)| {
                    BitString::from(TypedBits::from(value as u64).unsigned_cast(width).expect(
                        "Unsigned cast must succeed - the width was chosen to ensure it would",
                    ))
                })
                .flat_map(|bs| bs.bits().to_vec())
                .collect::<Vec<_>>();
            let Operand::Literal(test_value) = self
                .allocate_literal_from_bit_string(&BitString::Unsigned(dyn_slot_bit_strings), loc)
            else {
                panic!("Allocate literal returned a register?")
            };
            test_values.push((
                tl::CaseArgument::Literal(test_value),
                case.concrete_path.clone(),
            ))
        }
        Ok(DynamicIndexDetails {
            discriminant,
            table: test_values.into(),
        })
    }
    fn operand(&mut self, slot: Slot, loc: SourceOpCode) -> Result<Operand> {
        if let Some(operand) = self.reverse_operand_map.get(&(self.object.fn_id, slot)) {
            return Ok(*operand);
        }
        match slot {
            Slot::Literal(literal_id) => {
                let bits = &self.object.literals[&literal_id];
                let operand = self.allocate_literal(bits, loc);
                let loc = self.object.symbols.slot_map[&slot];
                self.symbols.operand_map.insert(operand, loc);
                self.reverse_operand_map
                    .insert((self.object.fn_id, slot), operand);
                self.operand_map.insert(operand, (self.object.fn_id, slot));
                Ok(operand)
            }
            Slot::Register(register_id) => {
                let kind = &self.object.kind[&register_id];
                let operand = self.allocate_register(kind, loc);
                let loc = self.object.symbols.slot_map[&slot];
                self.symbols.operand_map.insert(operand, loc);
                self.reverse_operand_map
                    .insert((self.object.fn_id, slot), operand);
                self.operand_map.insert(operand, (self.object.fn_id, slot));
                Ok(operand)
            }
            Slot::Empty => panic!("empty slot"), //Err(self.raise_ice(ICE::EmptySlotInRTL, id)),
        }
    }
    fn make_operand_list(&mut self, args: &[Slot], loc: SourceOpCode) -> Result<Vec<Operand>> {
        args.iter()
            .filter_map(|a| {
                if a.is_empty() {
                    None
                } else {
                    Some(self.operand(*a, loc))
                }
            })
            .collect()
    }
    fn make_array(&mut self, args: &hf::Array, loc: SourceOpCode) -> Result<()> {
        let hf::Array { lhs, elements } = args;
        if lhs.is_empty() {
            return Ok(());
        }
        let lhs = self.operand(*lhs, loc)?;
        let elements = self.make_operand_list(elements, loc)?;
        self.lop(
            tl::OpCode::Concat(tl::Concat {
                lhs,
                args: elements,
            }),
            loc,
        );
        Ok(())
    }
    fn make_resize(&mut self, cast: &hf::Cast, loc: SourceOpCode) -> Result<()> {
        let hf::Cast { lhs, arg, len } = cast;
        let len = len.ok_or_else(|| self.raise_ice(ICE::BitCastMissingRequiredLength, loc))?;
        if !lhs.is_empty() && !arg.is_empty() {
            let lhs = self.operand(*lhs, loc)?;
            let op_arg = self.operand(*arg, loc)?;
            self.lop(
                tl::OpCode::Cast(tl::Cast {
                    lhs,
                    arg: op_arg,
                    len,
                    kind: CastKind::Resize,
                }),
                loc,
            );
        }
        Ok(())
    }
    fn make_wrap(&mut self, wrap: &hf::Wrap, loc: SourceOpCode) -> Result<()> {
        let hf::Wrap { lhs, op, arg, kind } = wrap;
        let kind = kind.ok_or_else(|| self.raise_ice(ICE::WrapMissingKind, loc))?;
        let discriminant = match op {
            WrapOp::Ok | WrapOp::Some => self.allocate_literal(&true.typed_bits(), loc),
            WrapOp::Err | WrapOp::None => self.allocate_literal(&false.typed_bits(), loc),
        };
        let width = kind.bits() - 1;
        let lhs = self.operand(*lhs, loc)?;
        if width != 0 {
            let payload =
                self.allocate_register_with_register_kind(&RegisterKind::Unsigned(width), loc);
            let arg = *arg;
            let arg = match arg {
                Slot::Empty => self.allocate_literal(&false.typed_bits(), loc),
                _ => self.operand(arg, loc)?,
            };
            self.lop(
                tl::OpCode::Cast(tl::Cast {
                    lhs: payload,
                    arg,
                    len: width,
                    kind: CastKind::Resize,
                }),
                loc,
            );
            self.lop(
                tl::OpCode::Concat(Concat {
                    lhs,
                    args: vec![payload, discriminant],
                }),
                loc,
            );
        } else {
            self.lop(
                tl::OpCode::Assign(tl::Assign {
                    lhs,
                    rhs: discriminant,
                }),
                loc,
            );
        };
        Ok(())
    }
    fn make_as_bits(&mut self, cast: &hf::Cast, loc: SourceOpCode) -> Result<()> {
        let hf::Cast { lhs, arg, len } = cast;
        let len = len.ok_or_else(|| self.raise_ice(ICE::BitCastMissingRequiredLength, loc))?;
        if !lhs.is_empty() && !arg.is_empty() {
            let lhs = self.operand(*lhs, loc)?;
            let arg = self.operand(*arg, loc)?;
            self.lop(
                tl::OpCode::Cast(tl::Cast {
                    lhs,
                    arg,
                    len,
                    kind: CastKind::Unsigned,
                }),
                loc,
            );
        }
        Ok(())
    }
    fn make_as_signed(&mut self, cast: &hf::Cast, loc: SourceOpCode) -> Result<()> {
        let hf::Cast { lhs, arg, len } = cast;
        let len = len.ok_or_else(|| self.raise_ice(ICE::BitCastMissingRequiredLength, loc))?;
        if !lhs.is_empty() && !arg.is_empty() {
            let lhs = self.operand(*lhs, loc)?;
            let arg = self.operand(*arg, loc)?;
            self.lop(
                tl::OpCode::Cast(tl::Cast {
                    lhs,
                    arg,
                    len,
                    kind: CastKind::Signed,
                }),
                loc,
            );
        }
        Ok(())
    }
    fn make_assign(&mut self, assign: &hf::Assign, loc: SourceOpCode) -> Result<()> {
        let hf::Assign { lhs, rhs } = assign;
        if !lhs.is_empty() && !rhs.is_empty() {
            let lhs = self.operand(*lhs, loc)?;
            let rhs = self.operand(*rhs, loc)?;
            self.lop(tl::OpCode::Assign(tl::Assign { lhs, rhs }), loc);
        }
        Ok(())
    }
    fn make_xadd_or_xmul(
        &mut self,
        lhs: Operand,
        arg1: Operand,
        arg2: Operand,
        loc: SourceOpCode,
        op: tl::AluBinary,
    ) -> Result<()> {
        let Operand::Register(lhs_id) = lhs else {
            return Err(self.raise_ice(ICE::XopsResultMustBeRegister, loc));
        };
        let lhs_reg_kind = self.registers[&lhs_id];
        let arg1_cast = self.allocate_register_with_register_kind(&lhs_reg_kind, loc);
        let arg2_cast = self.allocate_register_with_register_kind(&lhs_reg_kind, loc);
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg1_cast,
                arg: arg1,
                len: lhs_reg_kind.len(),
                kind: CastKind::Resize,
            }),
            loc,
        );
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg2_cast,
                arg: arg2,
                len: lhs_reg_kind.len(),
                kind: CastKind::Resize,
            }),
            loc,
        );
        self.lop(
            tl::OpCode::Binary(tl::Binary {
                lhs,
                op,
                arg1: arg1_cast,
                arg2: arg2_cast,
            }),
            loc,
        );
        Ok(())
    }
    fn make_xsub(
        &mut self,
        lhs: Operand,
        arg1: Operand,
        arg2: Operand,
        loc: SourceOpCode,
    ) -> Result<()> {
        let Operand::Register(lhs_id) = lhs else {
            return Err(self.raise_ice(ICE::XopsResultMustBeRegister, loc));
        };
        // The cast operation has to be split into two steps depending
        // on the sign of the operands.  The result is always signed.
        let lhs_reg_kind = self.registers[&lhs_id];
        let lhs_len = lhs_reg_kind.len();
        let extension_kind = if self.operand_is_signed(arg1) {
            RegisterKind::Signed(lhs_len)
        } else {
            RegisterKind::Unsigned(lhs_len)
        };
        // First we extend the operands to the required number of bits
        let arg1_extend = self.allocate_register_with_register_kind(&extension_kind, loc);
        let arg2_extend = self.allocate_register_with_register_kind(&extension_kind, loc);
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg1_extend,
                arg: arg1,
                len: lhs_len,
                kind: CastKind::Resize,
            }),
            loc,
        );
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg2_extend,
                arg: arg2,
                len: lhs_len,
                kind: CastKind::Resize,
            }),
            loc,
        );
        // This guarantees that the sign bit will be zero when we reinterepret them as signed values
        let arg1_cast = self.allocate_register_with_register_kind(&lhs_reg_kind, loc);
        let arg2_cast = self.allocate_register_with_register_kind(&lhs_reg_kind, loc);
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg1_cast,
                arg: arg1_extend,
                len: lhs_reg_kind.len(),
                kind: CastKind::Signed,
            }),
            loc,
        );
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg2_cast,
                arg: arg2_extend,
                len: lhs_reg_kind.len(),
                kind: CastKind::Signed,
            }),
            loc,
        );
        self.lop(
            tl::OpCode::Binary(tl::Binary {
                lhs,
                op: tl::AluBinary::Sub,
                arg1: arg1_cast,
                arg2: arg2_cast,
            }),
            loc,
        );
        Ok(())
    }
    fn make_binary(&mut self, binary: &hf::Binary, loc: SourceOpCode) -> Result<()> {
        let hf::Binary {
            lhs,
            op,
            arg1,
            arg2,
        } = *binary;
        if lhs.is_empty() {
            return Ok(());
        }
        let lhs = self.operand(lhs, loc)?;
        let arg1 = self.operand(arg1, loc)?;
        let arg2 = self.operand(arg2, loc)?;
        let mut rtl_binop = |op| {
            self.lop(
                tl::OpCode::Binary(tl::Binary {
                    lhs,
                    op,
                    arg1,
                    arg2,
                }),
                loc,
            );
            Ok(())
        };
        match op {
            AluBinary::Add => rtl_binop(tl::AluBinary::Add),
            AluBinary::Sub => rtl_binop(tl::AluBinary::Sub),
            AluBinary::Mul => rtl_binop(tl::AluBinary::Mul),
            AluBinary::BitAnd => rtl_binop(tl::AluBinary::BitAnd),
            AluBinary::BitOr => rtl_binop(tl::AluBinary::BitOr),
            AluBinary::BitXor => rtl_binop(tl::AluBinary::BitXor),
            AluBinary::Shl => rtl_binop(tl::AluBinary::Shl),
            AluBinary::Shr => rtl_binop(tl::AluBinary::Shr),
            AluBinary::Eq => rtl_binop(tl::AluBinary::Eq),
            AluBinary::Ne => rtl_binop(tl::AluBinary::Ne),
            AluBinary::Lt => rtl_binop(tl::AluBinary::Lt),
            AluBinary::Le => rtl_binop(tl::AluBinary::Le),
            AluBinary::Gt => rtl_binop(tl::AluBinary::Gt),
            AluBinary::Ge => rtl_binop(tl::AluBinary::Ge),
            AluBinary::XAdd => self.make_xadd_or_xmul(lhs, arg1, arg2, loc, tl::AluBinary::Add),
            AluBinary::XSub => self.make_xsub(lhs, arg1, arg2, loc),
            AluBinary::XMul => self.make_xadd_or_xmul(lhs, arg1, arg2, loc, tl::AluBinary::Mul),
        }
    }
    fn make_case_argument(
        &mut self,
        case_argument: &hf::CaseArgument,
        loc: SourceOpCode,
    ) -> Result<tl::CaseArgument> {
        match case_argument {
            hf::CaseArgument::Slot(slot) => {
                if !slot.is_literal() {
                    return Err(self.raise_ice(ICE::MatchPatternValueMustBeLiteral, loc));
                };
                let operand = self.operand(*slot, loc)?;
                let Operand::Literal(literal_id) = operand else {
                    return Err(self.raise_ice(ICE::MatchPatternValueMustBeLiteral, loc));
                };
                Ok(tl::CaseArgument::Literal(literal_id))
            }
            hf::CaseArgument::Wild => Ok(tl::CaseArgument::Wild),
        }
    }
    fn make_case(&mut self, case: &hf::Case, loc: SourceOpCode) -> Result<()> {
        let hf::Case {
            lhs,
            discriminant,
            table,
        } = case;
        if lhs.is_empty() {
            return Ok(());
        }
        let lhs = self.operand(*lhs, loc)?;
        let discriminant = self.operand(*discriminant, loc)?;
        let table = table
            .iter()
            .map(|(cond, val)| {
                let cond = self.make_case_argument(cond, loc)?;
                let val = self.operand(*val, loc)?;
                Ok((cond, val))
            })
            .collect::<Result<Vec<_>>>()?;
        self.lop(
            tl::OpCode::Case(tl::Case {
                lhs,
                discriminant,
                table,
            }),
            loc,
        );
        Ok(())
    }
    fn make_dynamic_splice(&mut self, splice: &hf::Splice, loc: SourceOpCode) -> Result<()> {
        let hf::Splice {
            lhs,
            orig,
            path,
            subst,
        } = splice;
        if lhs.is_empty() {
            return Ok(());
        }
        let arg_kind = self.object.kind(*orig);
        let details = self.build_dynamic_index(arg_kind, path, loc)?;
        let lhs_kind = self.object.kind(*lhs);
        let lhs = self.operand(*lhs, loc)?;
        let orig = self.operand(*orig, loc)?;
        let subst = self.operand(*subst, loc)?;
        let mut table = vec![];
        for (literal, path) in details.table {
            let case_value = self.allocate_register(&lhs_kind, loc);
            let (bit_range, _) = bit_range(arg_kind, &path)?;
            self.lop(
                tl::OpCode::Splice(tl::Splice {
                    lhs: case_value,
                    orig,
                    bit_range,
                    value: subst,
                }),
                loc,
            );
            table.push((literal, case_value));
        }
        self.lop(
            tl::OpCode::Case(tl::Case {
                lhs,
                discriminant: details.discriminant,
                table,
            }),
            loc,
        );
        Ok(())
    }
    fn make_enum(&mut self, enumerate: &hf::Enum, id: SourceOpCode) -> Result<()> {
        let hf::Enum {
            lhs,
            fields,
            template,
        } = enumerate;
        if lhs.is_empty() {
            return Ok(());
        }
        let kind = template.kind;
        let discriminant = template.discriminant()?.as_i64()?;
        let mut rhs = self.allocate_literal(template, id);
        for field in fields {
            let field_value = self.operand(field.value, id)?;
            let path = Path::default()
                .payload_by_value(discriminant)
                .member(&field.member);
            let (field_range, _) = bit_range(kind, &path)?;
            let reg = self.allocate_register(&kind, id);
            self.lop(
                tl::OpCode::Splice(tl::Splice {
                    lhs: reg,
                    orig: rhs,
                    bit_range: field_range,
                    value: field_value,
                }),
                id,
            );
            rhs = reg;
        }
        let lhs = self.operand(*lhs, id)?;
        self.lop(tl::OpCode::Assign(tl::Assign { lhs, rhs }), id);
        Ok(())
    }
    fn make_exec(&mut self, exec: &hf::Exec, loc: SourceOpCode) -> Result<()> {
        let hf::Exec { lhs, id, args } = exec;
        if lhs.is_empty() {
            return Ok(());
        }
        // Look up the function ID from the external functions.
        let func = &self.object.externals[id];
        self.rhifs.insert(func.fn_id, func.as_ref().clone());
        // Compile it...
        let func_rtl = compile_rtl(func)?;
        // Inline it.
        let mut operand_translation = BTreeMap::new();
        // Rebind the arguments to local registers, and copy the values into them
        for (fn_arg, arg) in func_rtl.arguments.iter().zip(args) {
            if let Some(fn_reg) = fn_arg {
                let fn_reg_in_our_space =
                    self.allocate_register_with_register_kind(&func_rtl.register_kind[fn_reg], loc);
                operand_translation.insert(Operand::Register(*fn_reg), fn_reg_in_our_space);
                let arg = self.operand(*arg, loc)?;
                self.lop(
                    tl::OpCode::Assign(tl::Assign {
                        lhs: fn_reg_in_our_space,
                        rhs: arg,
                    }),
                    loc,
                );
            }
        }
        let mut op_remap = |operand| {
            if operand_translation.contains_key(&operand) {
                return operand_translation[&operand];
            }
            let new_operand = match operand {
                Operand::Literal(old_lit_id) => {
                    let old_lit = func_rtl.literals[&old_lit_id].clone();
                    self.allocate_literal_from_bit_string(&old_lit, loc)
                }
                Operand::Register(old_reg_id) => {
                    let kind = func_rtl.register_kind[&old_reg_id];
                    self.allocate_register_with_register_kind(&kind, loc)
                }
            };
            operand_translation.insert(operand, new_operand);
            new_operand
        };
        let return_register = op_remap(func_rtl.return_register);
        // Translate each operation and add it to the existing function (inline).
        // Remap the operands of the opcode to allocate from the current function.
        // Note that we need to ensure that if a register is allocated it is reused..
        let translated = func_rtl
            .ops
            .into_iter()
            .map(|old_lop| {
                let op = remap_operands(old_lop.op, &mut op_remap);
                (op, old_lop.loc).into()
            })
            .collect::<Vec<_>>();
        self.ops.extend(translated);
        let lhs = self.operand(*lhs, loc)?;
        self.lop(
            tl::OpCode::Assign(tl::Assign {
                lhs,
                rhs: return_register,
            }),
            loc,
        );
        for old_op in func_rtl.symbols.operand_map.keys() {
            let new_op = operand_translation[old_op];
            let loc = func_rtl.symbols.operand_map[old_op];
            self.symbols.operand_map.insert(new_op, loc);
            if let Some(name) = func_rtl.symbols.operand_names.get(old_op) {
                self.symbols.operand_names.insert(new_op, name.clone());
            }
        }
        self.symbols
            .source_set
            .extend(func_rtl.symbols.source_set.sources);
        Ok(())
    }
    /// Lower the RHIF dynamic index to RTL
    /// Note that the dynamic index op in RHIF is something like
    ///     a.foo[n].bar.baz[m]
    /// where (n, m) are the dynamic slots.  We will lower this into
    /// a case statement.  The final result will look something like
    ///      case (n,m) {
    ///          0, 0  => a.foo[0].bar.baz[0]
    ///          0, 1  => a.foo[0].bar.baz[1]
    ///           etc.
    ///      }
    fn make_dynamic_index(&mut self, index: &hf::Index, loc: SourceOpCode) -> Result<()> {
        let hf::Index { lhs, arg, path } = index;
        if lhs.is_empty() {
            return Ok(());
        }
        let arg_kind = self.object.kind(*arg);
        let details = self.build_dynamic_index(arg_kind, path, loc)?;
        let lhs_kind = self.object.kind(index.lhs);
        let arg = self.operand(*arg, loc)?;
        // Iterate over the cases
        let mut table = vec![];
        for (literal, path) in details.table {
            let case_value = self.allocate_register(&lhs_kind, loc);
            let (bit_range, _) = bit_range(arg_kind, &path)?;
            self.lop(
                tl::OpCode::Index(tl::Index {
                    lhs: case_value,
                    arg,
                    bit_range,
                }),
                loc,
            );
            table.push((literal, case_value));
        }
        let lhs = self.operand(*lhs, loc)?;
        self.lop(
            tl::OpCode::Case(tl::Case {
                lhs,
                discriminant: details.discriminant,
                table,
            }),
            loc,
        );
        Ok(())
    }
    fn make_index(&mut self, index: &hf::Index, loc: SourceOpCode) -> Result<()> {
        if index.lhs.is_empty() {
            return Ok(());
        }
        if index.path.any_dynamic() {
            return self.make_dynamic_index(index, loc);
        }
        let arg_ty = self.object.kind(index.arg);
        let (bit_range, _) = bit_range(arg_ty, &index.path)?;
        let lhs = self.operand(index.lhs, loc)?;
        let arg = self.operand(index.arg, loc)?;
        self.lop(
            tl::OpCode::Index(tl::Index {
                lhs,
                arg,
                bit_range,
            }),
            loc,
        );
        Ok(())
    }
    fn make_repeat(&mut self, repeat: &hf::Repeat, loc: SourceOpCode) -> Result<()> {
        let hf::Repeat { lhs, value, len } = *repeat;
        if lhs.is_empty() {
            return Ok(());
        }
        let lhs = self.operand(lhs, loc)?;
        let arg = self.operand(value, loc)?;
        let args = vec![arg; len as usize];
        self.lop(tl::OpCode::Concat(tl::Concat { lhs, args }), loc);
        Ok(())
    }
    fn make_retime(&mut self, retime: &hf::Retime, loc: SourceOpCode) -> Result<()> {
        let hf::Retime { lhs, arg, color: _ } = *retime;
        if lhs.is_empty() {
            return Ok(());
        }
        let lhs = self.operand(lhs, loc)?;
        let rhs = self.operand(arg, loc)?;
        self.lop(tl::OpCode::Assign(tl::Assign { lhs, rhs }), loc);
        Ok(())
    }
    fn make_select(&mut self, select: &hf::Select, loc: SourceOpCode) -> Result<()> {
        let hf::Select {
            lhs,
            cond,
            true_value,
            false_value,
        } = *select;
        if lhs.is_empty() {
            return Ok(());
        }
        let lhs = self.operand(lhs, loc)?;
        let cond = self.operand(cond, loc)?;
        let true_value = self.operand(true_value, loc)?;
        let false_value = self.operand(false_value, loc)?;
        self.lop(
            tl::OpCode::Select(tl::Select {
                lhs,
                cond,
                true_value,
                false_value,
            }),
            loc,
        );
        Ok(())
    }
    fn make_splice(&mut self, splice: &hf::Splice, loc: SourceOpCode) -> Result<()> {
        if splice.lhs.is_empty() {
            return Ok(());
        }
        if splice.path.any_dynamic() {
            return self.make_dynamic_splice(splice, loc);
        }
        let hf::Splice {
            lhs,
            orig,
            path,
            subst,
        } = splice;
        let orig_ty = self.object.kind(*orig);
        let (bit_range, _) = bit_range(orig_ty, path)?;
        let lhs = self.operand(*lhs, loc)?;
        let orig = self.operand(*orig, loc)?;
        let subst = self.operand(*subst, loc)?;
        self.lop(
            tl::OpCode::Splice(tl::Splice {
                lhs,
                orig,
                bit_range,
                value: subst,
            }),
            loc,
        );
        Ok(())
    }
    fn make_struct(&mut self, strukt: &hf::Struct, loc: SourceOpCode) -> Result<()> {
        let hf::Struct {
            lhs,
            fields,
            rest,
            template,
        } = strukt;
        if lhs.is_empty() {
            return Ok(());
        }
        let lhs = self.operand(*lhs, loc)?;
        let kind = template.kind;
        let mut rhs = if let Some(rest) = rest {
            self.operand(*rest, loc)?
        } else {
            self.allocate_literal(template, loc)
        };
        for field in fields {
            let field_value = self.operand(field.value, loc)?;
            let path = Path::default().member(&field.member);
            let (field_range, _) = bit_range(kind, &path)?;
            let reg = self.allocate_register(&kind, loc);
            self.lop(
                tl::OpCode::Splice(tl::Splice {
                    lhs: reg,
                    orig: rhs,
                    bit_range: field_range,
                    value: field_value,
                }),
                loc,
            );
            rhs = reg;
        }
        self.lop(tl::OpCode::Assign(tl::Assign { lhs, rhs }), loc);
        Ok(())
    }
    fn make_tuple(&mut self, tuple: &hf::Tuple, loc: SourceOpCode) -> Result<()> {
        let hf::Tuple { lhs, fields } = tuple;
        if lhs.is_empty() {
            return Ok(());
        }
        let lhs = self.operand(*lhs, loc)?;
        let args = self.make_operand_list(fields, loc)?;
        self.lop(tl::OpCode::Concat(tl::Concat { lhs, args }), loc);
        Ok(())
    }
    fn make_xshr(&mut self, lhs: Operand, arg: Operand, shift: usize, loc: SourceOpCode) {
        // First apply the right shift operation
        let count = b8(shift as u128);
        let right_shift_amount = self.allocate_literal(&count.typed_bits(), loc);
        let operand_bits = self.operand_bit_width(arg);
        let operand_signed = self.operand_is_signed(arg);
        let arg_shifted = if operand_signed {
            self.allocate_register_with_register_kind(&RegisterKind::Signed(operand_bits), loc)
        } else {
            self.allocate_register_with_register_kind(&RegisterKind::Unsigned(operand_bits), loc)
        };
        self.lop(
            tl::OpCode::Binary(tl::Binary {
                lhs: arg_shifted,
                op: tl::AluBinary::Shr,
                arg1: arg,
                arg2: right_shift_amount,
            }),
            loc,
        );
        // Now resize the result into the LHS
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs,
                arg: arg_shifted,
                len: operand_bits.saturating_sub(shift),
                kind: CastKind::Resize,
            }),
            loc,
        )
    }
    fn make_xshl(&mut self, lhs: Operand, arg: Operand, count: usize, loc: SourceOpCode) {
        // First pad the operand by the shift count
        let arg_len = self.operand_bit_width(arg);
        let arg_padded = if self.operand_is_signed(arg) {
            self.allocate_register_with_register_kind(&RegisterKind::Signed(arg_len + count), loc)
        } else {
            self.allocate_register_with_register_kind(&RegisterKind::Unsigned(arg_len + count), loc)
        };
        // Now we resize cast the argument into this larger register
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg_padded,
                arg,
                len: arg_len + count,
                kind: CastKind::Resize,
            }),
            loc,
        );
        let count = b8(count as u128);
        let left_shift_amount = self.allocate_literal(&count.typed_bits(), loc);
        // Now we issue the shl operation (lossy)
        self.lop(
            tl::OpCode::Binary(tl::Binary {
                lhs,
                op: tl::AluBinary::Shl,
                arg1: arg_padded,
                arg2: left_shift_amount,
            }),
            loc,
        );
    }
    fn make_xsgn(&mut self, lhs: Operand, arg: Operand, loc: SourceOpCode) {
        // The argument must be unsigned.
        // First pad the width by 1 bit
        let arg_len = self.operand_bit_width(arg);
        let arg_padded =
            self.allocate_register_with_register_kind(&RegisterKind::Unsigned(arg_len + 1), loc);
        // Now we resize cast the argument into this larger register
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg_padded,
                arg,
                len: arg_len + 1,
                kind: CastKind::Resize,
            }),
            loc,
        );
        // Next, we cast it as signed in this larger size
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs,
                arg: arg_padded,
                len: arg_len + 1,
                kind: CastKind::Signed,
            }),
            loc,
        );
    }
    fn make_xneg(&mut self, lhs: Operand, arg: Operand, loc: SourceOpCode) {
        // First pad the width by 1 bit
        let arg_len = self.operand_bit_width(arg);
        let mut arg_padded = if self.operand_is_signed(arg) {
            self.allocate_register_with_register_kind(&RegisterKind::Signed(arg_len + 1), loc)
        } else {
            self.allocate_register_with_register_kind(&RegisterKind::Unsigned(arg_len + 1), loc)
        };
        // Now we resize cast the argument into this larger register
        self.lop(
            tl::OpCode::Cast(tl::Cast {
                lhs: arg_padded,
                arg,
                len: arg_len + 1,
                kind: CastKind::Resize,
            }),
            loc,
        );
        // We need an extra step if the argument is unsigned
        if !self.operand_is_signed(arg) {
            let padded_and_signed =
                self.allocate_register_with_register_kind(&RegisterKind::Signed(arg_len + 1), loc);
            self.lop(
                tl::OpCode::Cast(tl::Cast {
                    lhs: padded_and_signed,
                    arg: arg_padded,
                    len: arg_len + 1,
                    kind: CastKind::Signed,
                }),
                loc,
            );
            arg_padded = padded_and_signed;
        }
        // Now we can negate the value
        self.lop(
            tl::OpCode::Unary(tl::Unary {
                lhs,
                op: tl::AluUnary::Neg,
                arg1: arg_padded,
            }),
            loc,
        );
    }
    fn make_unary(&mut self, unary: &hf::Unary, loc: SourceOpCode) -> Result<()> {
        let hf::Unary { lhs, op, arg1 } = *unary;
        if lhs.is_empty() {
            return Ok(());
        }
        let lhs = self.operand(lhs, loc)?;
        let arg1 = self.operand(arg1, loc)?;
        let mut unop = |op| self.lop(tl::OpCode::Unary(tl::Unary { lhs, op, arg1 }), loc);
        match op {
            hf::AluUnary::Neg => unop(tl::AluUnary::Neg),
            hf::AluUnary::Not => unop(tl::AluUnary::Not),
            hf::AluUnary::All => unop(tl::AluUnary::All),
            hf::AluUnary::Any => unop(tl::AluUnary::Any),
            hf::AluUnary::Xor => unop(tl::AluUnary::Xor),
            hf::AluUnary::Signed => unop(tl::AluUnary::Signed),
            hf::AluUnary::Unsigned => unop(tl::AluUnary::Unsigned),
            hf::AluUnary::Val => unop(tl::AluUnary::Val),
            hf::AluUnary::XExt(_) => {
                let lhs_len = self.operand_bit_width(lhs);
                self.lop(
                    tl::OpCode::Cast(tl::Cast {
                        lhs,
                        arg: arg1,
                        len: lhs_len,
                        kind: CastKind::Resize,
                    }),
                    loc,
                );
            }
            hf::AluUnary::XShl(cnt) => self.make_xshl(lhs, arg1, cnt, loc),
            hf::AluUnary::XShr(cnt) => self.make_xshr(lhs, arg1, cnt, loc),
            hf::AluUnary::XNeg => self.make_xneg(lhs, arg1, loc),
            hf::AluUnary::XSgn => self.make_xsgn(lhs, arg1, loc),
        };
        Ok(())
    }
    fn translate(mut self) -> Result<Self> {
        for (ndx, lop) in self.object.ops.iter().enumerate() {
            let loc = SourceOpCode::new(lop.loc, ndx);
            match &lop.op {
                hf::OpCode::Array(array) => {
                    self.make_array(array, loc)?;
                }
                hf::OpCode::AsBits(cast) => {
                    self.make_as_bits(cast, loc)?;
                }
                hf::OpCode::AsSigned(cast) => {
                    self.make_as_signed(cast, loc)?;
                }
                hf::OpCode::Assign(assign) => {
                    self.make_assign(assign, loc)?;
                }
                hf::OpCode::Binary(binary) => {
                    self.make_binary(binary, loc)?;
                }
                hf::OpCode::Case(case) => {
                    self.make_case(case, loc)?;
                }
                hf::OpCode::Comment(comment) => {
                    self.lop(tl::OpCode::Comment(comment.clone()), loc);
                }
                hf::OpCode::Enum(enumerate) => {
                    self.make_enum(enumerate, loc)?;
                }
                hf::OpCode::Exec(exec) => {
                    self.make_exec(exec, loc)?;
                }
                hf::OpCode::Index(index) => {
                    self.make_index(index, loc)?;
                }
                hf::OpCode::Noop => {}
                hf::OpCode::Resize(cast) => {
                    self.make_resize(cast, loc)?;
                }
                hf::OpCode::Repeat(repeat) => {
                    self.make_repeat(repeat, loc)?;
                }
                hf::OpCode::Retime(retime) => {
                    self.make_retime(retime, loc)?;
                }
                hf::OpCode::Select(select) => {
                    self.make_select(select, loc)?;
                }
                hf::OpCode::Splice(splice) => {
                    self.make_splice(splice, loc)?;
                }
                hf::OpCode::Struct(strukt) => {
                    self.make_struct(strukt, loc)?;
                }
                hf::OpCode::Tuple(tuple) => {
                    self.make_tuple(tuple, loc)?;
                }
                hf::OpCode::Unary(unary) => {
                    self.make_unary(unary, loc)?;
                }
                hf::OpCode::Wrap(wrap) => {
                    self.make_wrap(wrap, loc)?;
                }
            }
        }
        Ok(self)
    }
}

fn compile_rtl(object: &rhif::Object) -> Result<rtl::object::Object> {
    let mut compiler = RTLCompiler::new(object).translate()?;
    let fallback = object.symbols.source_set.fallback(object.fn_id);
    let arguments = object
        .arguments
        .iter()
        .map(|x| {
            if object.kind[x].is_empty() {
                None
            } else if let Ok(Operand::Register(reg_id)) =
                compiler.operand(Slot::Register(*x), SourceOpCode::new(fallback, 0))
            {
                Some(reg_id)
            } else {
                None
            }
        })
        .collect();
    let return_register = compiler.reverse_operand_map[&(object.fn_id, object.return_slot)];
    Ok(rtl::object::Object {
        symbols: compiler.symbols,
        literals: compiler.literals,
        return_register,
        register_kind: compiler.registers,
        ops: compiler.ops,
        arguments,
        name: object.name.clone(),
        fn_id: object.fn_id,
        rhifs: compiler.rhifs,
    })
}

pub fn compile_to_rtl(object: &rhif::object::Object) -> Result<rtl::object::Object> {
    compile_rtl(object)
}

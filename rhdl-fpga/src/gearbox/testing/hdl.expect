// synchronous circuit rhdl_fpga::gearbox::reducer::U<rhdl::rhdl_typenum::consts::U16, rhdl::rhdl_typenum::consts::U8>
module top(input wire [1:0] clock_reset, input wire [17:0] i, output wire [9:0] o);
    wire [27:0] od;
    wire [17:0] d;
    wire [17:0] q;
    assign o = od[9:0];
    top_data_store c0 (.clock_reset(clock_reset),.i(d[17:2]),.o(q[17:2]));
    top_state c1 (.clock_reset(clock_reset),.i(d[1:0]),.o(q[1:0]));
    assign od = kernel_kernel(clock_reset, i, q);
    assign d = od[27:10];
    function [27:0] kernel_kernel(input reg [1:0] arg_0, input reg [17:0] arg_1, input reg [17:0] arg_2);
        reg [1:0] r0;
        reg [17:0] r1;
        reg [17:0] r2;
        reg [15:0] r3;
        reg [17:0] r4;
        reg [0:0] r5;
        reg [17:0] r6;
        reg [0:0] r7;
        reg [16:0] r8;
        reg [16:0] r10;
        reg [0:0] r11;
        reg [15:0] r12;
        reg [16:0] r14;
        reg [0:0] r16;
        reg [15:0] r17;
        reg [1:0] r18;
        reg [17:0] r20;
        reg [17:0] r21;
        reg [17:0] r22;
        reg [0:0] r23;
        reg [17:0] r24;
        reg [17:0] r25;
        reg [0:0] r26;
        reg [0:0] r27;
        reg [17:0] r28;
        reg [17:0] r29;
        reg [0:0] r30;
        reg [0:0] r31;
        reg [0:0] r32;
        reg [17:0] r33;
        reg [17:0] r34;
        reg [17:0] r35;
        reg [17:0] r36;
        reg [1:0] r37;
        reg [0:0] r38;
        reg [1:0] r39;
        reg [0:0] r40;
        reg [0:0] r41;
        reg [0:0] r42;
        reg [0:0] r43;
        reg [1:0] r44;
        reg [0:0] r45;
        reg [1:0] r46;
        reg [0:0] r47;
        reg [0:0] r48;
        reg [15:0] r49;
        reg [7:0] r51;
        reg [15:0] r52;
        reg [0:0] r53;
        reg [7:0] r54;
        reg [15:0] r55;
        reg [0:0] r56;
        reg [7:0] r57;
        reg [7:0] r58;
        reg [15:0] r59;
        reg [0:0] r60;
        reg [7:0] r61;
        reg [7:0] r62;
        reg [15:0] r63;
        reg [0:0] r64;
        reg [7:0] r65;
        reg [7:0] r66;
        reg [15:0] r67;
        reg [0:0] r68;
        reg [7:0] r69;
        reg [7:0] r70;
        reg [15:0] r71;
        reg [0:0] r72;
        reg [7:0] r73;
        reg [7:0] r74;
        reg [15:0] r75;
        reg [0:0] r76;
        reg [7:0] r77;
        reg [7:0] r78;
        reg [15:0] r79;
        reg [0:0] r80;
        reg [7:0] r81;
        reg [15:0] r83;
        reg [7:0] r85;
        reg [15:0] r86;
        reg [0:0] r87;
        reg [7:0] r88;
        reg [15:0] r89;
        reg [0:0] r90;
        reg [7:0] r91;
        reg [7:0] r92;
        reg [15:0] r93;
        reg [0:0] r94;
        reg [7:0] r95;
        reg [7:0] r96;
        reg [15:0] r97;
        reg [0:0] r98;
        reg [7:0] r99;
        reg [7:0] r100;
        reg [15:0] r101;
        reg [0:0] r102;
        reg [7:0] r103;
        reg [7:0] r104;
        reg [15:0] r105;
        reg [0:0] r106;
        reg [7:0] r107;
        reg [7:0] r108;
        reg [15:0] r109;
        reg [0:0] r110;
        reg [7:0] r111;
        reg [7:0] r112;
        reg [15:0] r113;
        reg [0:0] r114;
        reg [7:0] r115;
        reg [7:0] r117;
        reg [8:0] r118;
        reg [7:0] r119;
        reg [8:0] r122;
        reg [9:0] r123;
        reg [9:0] r124;
        reg [27:0] r125;
        reg [1:0] r126;
        localparam l0 = 18'bxxxxxxxxxxxxxxxxxx;
        localparam l1 = 1'b1;
        localparam l2 = 1'b0;
        localparam l3 = 17'b00000000000000000;
        localparam l4 = 1'b1;
        localparam l5 = 2'b10;
        localparam l6 = 2'b01;
        localparam l7 = 2'b10;
        localparam l8 = 2'b00;
        localparam l9 = 2'b00;
        localparam l10 = 2'b10;
        localparam l11 = 2'b01;
        localparam l12 = 2'b00;
        localparam l13 = 2'b01;
        localparam l14 = 2'b01;
        localparam l16 = 16'b0000000000000001;
        localparam l18 = 8'b00000001;
        localparam l19 = 8'b00000000;
        localparam l20 = 16'b0000000000000010;
        localparam l22 = 8'b00000010;
        localparam l23 = 16'b0000000000000100;
        localparam l25 = 8'b00000100;
        localparam l26 = 16'b0000000000001000;
        localparam l28 = 8'b00001000;
        localparam l29 = 16'b0000000000010000;
        localparam l31 = 8'b00010000;
        localparam l32 = 16'b0000000000100000;
        localparam l34 = 8'b00100000;
        localparam l35 = 16'b0000000001000000;
        localparam l37 = 8'b01000000;
        localparam l38 = 16'b0000000010000000;
        localparam l40 = 8'b10000000;
        localparam l41 = 16'b0000000100000000;
        localparam l43 = 8'b00000001;
        localparam l44 = 8'b00000000;
        localparam l45 = 16'b0000001000000000;
        localparam l47 = 8'b00000010;
        localparam l48 = 16'b0000010000000000;
        localparam l50 = 8'b00000100;
        localparam l51 = 16'b0000100000000000;
        localparam l53 = 8'b00001000;
        localparam l54 = 16'b0001000000000000;
        localparam l56 = 8'b00010000;
        localparam l57 = 16'b0010000000000000;
        localparam l59 = 8'b00100000;
        localparam l60 = 16'b0100000000000000;
        localparam l62 = 8'b01000000;
        localparam l63 = 16'b1000000000000000;
        localparam l65 = 8'b10000000;
        localparam l66 = 1'b1;
        localparam l69 = 10'bxxxxxxxxxx;
        localparam l71 = 9'b000000000;
        begin
            r126 = arg_0;
            r6 = arg_1;
            r1 = arg_2;
            // let d = D::<DW,DN>::dont_care();
            //
            // d.state = q.state;
            //
            r0 = r1[1:0];
            r2 = l0; r2[1:0] = r0;
            // d.data_store = q.data_store;
            //
            r3 = r1[17:2];
            r4 = r2; r4[17:2] = r3;
            // let stop_in = !i.ready;
            //
            r5 = r6[17];
            r7 = ~(r5);
            // let (in_valid, in_data, ) = unpack(i.data);
            //
            r8 = r6[16:0];
            // match opt {
            //    _#false => (false, T::default(), ),
            //    Some(t, )#true => (true, t, ),
            // }
            //
            r11 = r8[16];
            r12 = r8[15:0];
            r14 = { r12, l1 };
            case (r11)
                1'b0: r10 = l3;
                1'b1: r10 = r14;
            endcase
            r16 = r10[0];
            r17 = r10[16:1];
            // match q.state {
            //    const State::Empty => {
            //       if in_valid {
            //          d.data_store = in_data;
            //          d.state = State :: Load2;
            //       }
            //
            //    }
            //    ,
            //    const State::Load2 => {
            //       if !stop_in {
            //          d.state = State :: Load1;
            //       }
            //
            //    }
            //    ,
            //    const State::Load1 => {
            //       if !stop_in && in_valid {
            //          d.data_store = in_data;
            //          d.state = State :: Load2;
            //       }
            //        else if !stop_in && !in_valid {
            //          d.state = State :: Empty;
            //       }
            //
            //    }
            //    ,
            // }
            //
            r18 = r1[1:0];
            // if in_valid {
            //    d.data_store = in_data;
            //    d.state = State :: Load2;
            // }
            //
            //
            // d.data_store = in_data;
            //
            r20 = r4; r20[17:2] = r17;
            // d.state = State :: Load2;
            //
            r21 = r20; r21[1:0] = l5;
            r22 = (r16) ? (r21) : (r4);
            // if !stop_in {
            //    d.state = State :: Load1;
            // }
            //
            //
            r23 = ~(r7);
            // d.state = State :: Load1;
            //
            r24 = r4; r24[1:0] = l6;
            r25 = (r23) ? (r24) : (r4);
            // if !stop_in && in_valid {
            //    d.data_store = in_data;
            //    d.state = State :: Load2;
            // }
            //  else if !stop_in && !in_valid {
            //    d.state = State :: Empty;
            // }
            //
            //
            r26 = ~(r7);
            r27 = r26 & r16;
            // d.data_store = in_data;
            //
            r28 = r4; r28[17:2] = r17;
            // d.state = State :: Load2;
            //
            r29 = r28; r29[1:0] = l7;
            r30 = ~(r7);
            r31 = ~(r16);
            r32 = r30 & r31;
            // d.state = State :: Empty;
            //
            r33 = r4; r33[1:0] = l8;
            r34 = (r32) ? (r33) : (r4);
            r35 = (r27) ? (r29) : (r34);
            case (r18)
                2'b00: r36 = r22;
                2'b10: r36 = r25;
                2'b01: r36 = r35;
            endcase
            // let ready_out = q.state == State :: Empty || (q.state == State :: Load1 && !stop_in);
            //
            r37 = r1[1:0];
            r38 = r37 == l12;
            r39 = r1[1:0];
            r40 = r39 == l13;
            r41 = ~(r7);
            r42 = r40 & r41;
            r43 = r38 | r42;
            // let mux = q.state == State :: Load1;
            //
            r44 = r1[1:0];
            r45 = r44 == l14;
            // let output_valid = q.state != State :: Empty;
            //
            r46 = r1[1:0];
            r47 = |(r46);
            // let o = O::<DN>::dont_care();
            //
            // let mux_output = if !mux {
            //    lsbs(q.data_store)
            // }
            //  else {
            //    msbs(q.data_store)
            // }
            // ;
            //
            r48 = ~(r45);
            // lsbs(q.data_store)
            //
            r49 = r1[17:2];
            // let o = bits(0);
            //
            // for i in 0..N :: BITS {
            //    if n & (1 << i) != 0 {
            //       o |= 1 << i
            //    }
            //
            // }
            //
            //
            // if n & (1 << i) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r52 = r49 & l16;
            r53 = |(r52);
            // o |= 1 << i
            //
            r54 = (r53) ? (l18) : (l19);
            // if n & (1 << i) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r55 = r49 & l20;
            r56 = |(r55);
            // o |= 1 << i
            //
            r57 = r54 | l22;
            r58 = (r56) ? (r57) : (r54);
            // if n & (1 << i) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r59 = r49 & l23;
            r60 = |(r59);
            // o |= 1 << i
            //
            r61 = r58 | l25;
            r62 = (r60) ? (r61) : (r58);
            // if n & (1 << i) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r63 = r49 & l26;
            r64 = |(r63);
            // o |= 1 << i
            //
            r65 = r62 | l28;
            r66 = (r64) ? (r65) : (r62);
            // if n & (1 << i) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r67 = r49 & l29;
            r68 = |(r67);
            // o |= 1 << i
            //
            r69 = r66 | l31;
            r70 = (r68) ? (r69) : (r66);
            // if n & (1 << i) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r71 = r49 & l32;
            r72 = |(r71);
            // o |= 1 << i
            //
            r73 = r70 | l34;
            r74 = (r72) ? (r73) : (r70);
            // if n & (1 << i) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r75 = r49 & l35;
            r76 = |(r75);
            // o |= 1 << i
            //
            r77 = r74 | l37;
            r78 = (r76) ? (r77) : (r74);
            // if n & (1 << i) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r79 = r49 & l38;
            r80 = |(r79);
            // o |= 1 << i
            //
            r81 = r78 | l40;
            r51 = (r80) ? (r81) : (r78);
            // o
            //
            // msbs(q.data_store)
            //
            r83 = r1[17:2];
            // let o = bits(0);
            //
            // for i in 0..N :: BITS {
            //    if n & (1 << (M :: BITS - N :: BITS + i)) != 0 {
            //       o |= 1 << i
            //    }
            //
            // }
            //
            //
            // if n & (1 << (M :: BITS - N :: BITS + i)) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r86 = r83 & l41;
            r87 = |(r86);
            // o |= 1 << i
            //
            r88 = (r87) ? (l43) : (l44);
            // if n & (1 << (M :: BITS - N :: BITS + i)) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r89 = r83 & l45;
            r90 = |(r89);
            // o |= 1 << i
            //
            r91 = r88 | l47;
            r92 = (r90) ? (r91) : (r88);
            // if n & (1 << (M :: BITS - N :: BITS + i)) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r93 = r83 & l48;
            r94 = |(r93);
            // o |= 1 << i
            //
            r95 = r92 | l50;
            r96 = (r94) ? (r95) : (r92);
            // if n & (1 << (M :: BITS - N :: BITS + i)) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r97 = r83 & l51;
            r98 = |(r97);
            // o |= 1 << i
            //
            r99 = r96 | l53;
            r100 = (r98) ? (r99) : (r96);
            // if n & (1 << (M :: BITS - N :: BITS + i)) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r101 = r83 & l54;
            r102 = |(r101);
            // o |= 1 << i
            //
            r103 = r100 | l56;
            r104 = (r102) ? (r103) : (r100);
            // if n & (1 << (M :: BITS - N :: BITS + i)) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r105 = r83 & l57;
            r106 = |(r105);
            // o |= 1 << i
            //
            r107 = r104 | l59;
            r108 = (r106) ? (r107) : (r104);
            // if n & (1 << (M :: BITS - N :: BITS + i)) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r109 = r83 & l60;
            r110 = |(r109);
            // o |= 1 << i
            //
            r111 = r108 | l62;
            r112 = (r110) ? (r111) : (r108);
            // if n & (1 << (M :: BITS - N :: BITS + i)) != 0 {
            //    o |= 1 << i
            // }
            //
            //
            r113 = r83 & l63;
            r114 = |(r113);
            // o |= 1 << i
            //
            r115 = r112 | l65;
            r85 = (r114) ? (r115) : (r112);
            // o
            //
            r117 = (r48) ? (r51) : (r85);
            // o.data = if output_valid {
            //    Some(mux_output)
            // }
            //  else {
            //    None()
            // }
            // ;
            //
            // Some(mux_output)
            //
            r119 = r117[7:0];
            r118 = { l66, r119 };
            // None()
            //
            r122 = (r47) ? (r118) : (l71);
            r123 = l69; r123[8:0] = r122;
            // o.ready = ready_out;
            //
            r124 = r123; r124[9:9] = r43;
            // (o, d, )
            //
            r125 = { r36, r124 };
            kernel_kernel = r125;
        end
    endfunction
endmodule
//
module top_data_store(input wire [1:0] clock_reset, input wire [15:0] i, output reg [15:0] o);
    wire [0:0] clock;
    wire [0:0] reset;
    initial begin
        o = 16'b0000000000000000;
    end
    assign clock = clock_reset[0];
    assign reset = clock_reset[1];
    always @(posedge clock) begin
        if (reset)
        begin
            o <= 16'b0000000000000000;
        end else begin
            o <= i;
        end
    end
endmodule
//
module top_marker_phantom_b8();
endmodule
//
module top_state(input wire [1:0] clock_reset, input wire [1:0] i, output reg [1:0] o);
    wire [0:0] clock;
    wire [0:0] reset;
    initial begin
        o = 2'b00;
    end
    assign clock = clock_reset[0];
    assign reset = clock_reset[1];
    always @(posedge clock) begin
        if (reset)
        begin
            o <= 2'b00;
        end else begin
            o <= i;
        end
    end
endmodule
